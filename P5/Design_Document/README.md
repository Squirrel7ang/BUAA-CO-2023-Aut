# Design Document


## 指令支持

本次课下P5所设计的CPU需要实现以下指令：
|Ins    |31-26  |25-21  |20-16  |15-11      |10-6   |5-0    |
|-------|-------|-------|-------|-----------|-------|-------|
|       |Opcode |       |       |           |       |Func   |
|add    |000000 |rs_5   |rt_5   |rd_5       |00000  |100000 |
|sub    |000000 |rs_5   |rt_5   |rd_5       |00000  |100010 |
|ori    |001101 |rs_5   |rt_5   |imm_16     |       |       |
|lw     |100011 |base_5 |rt_5   |offset_16  |       |       |
|sw     |101011 |base_5 |rt_5   |offset_16  |       |       |
|beq    |000100 |rs_5   |rt_5   |offset_16  |       |       |
|lui    |001111 |00000  |rt_5   |imm_16     |       |       |
|nop    |000000 |00000  |00000  |00000      |00000  |000000 |
|jal    |000011 |imm_26 |       |           |       |       |
|jr     |000000 |rs_5   |00000  |00000      |00000  |001000 |

## 控制器
采用**集中式译码**

可以根据不同级的结果改变控制信号

控制信号有：

|Output         |add    |sub    |ori    |beq    |sw     |lw     |lui    |jal    |jr     |
| :--:          | :--:  | :--:  | :--:  | :--:  | :--:  | :--:  | :--:  | :--:  | :--:  |
|MemWrite       |0      |0      |0      |0      |1      |0      |0      |0      |0      |
|RegWrite       |1      |1      |1      |0      |0      |1      |1      |1      |0      |
|Jr             |0      |0      |0      |0      |0      |0      |0      |0      |1      |
|Jump           |0      |0      |0      |0      |0      |0      |0      |1      |0      |
|Branch         |0      |0      |0      |1      |0      |0      |0      |0      |0      |
|ExtOp          |0      |0      |0      |1      |1      |1      |0      |0      |0      |
|ALUASrc        |rd1    |rd1    |rd1    |rd1    |rd1    |rd1    |rd1    |rd1    |rd1    |
|ALUBSrc        |rd2    |rd2    |imm    |rd2    |imm    |imm    |imm    |rd2    |rd2    |
|RegDst[1:0]    |rd     |rd     |rt     |default|rt     |rt     |rt     |ra     |default|
|RegDataSrc[1:0]|alu    |alu    |alu    |default|default|mem    |alu    |pc     |pc     |
|MemType        |word   |word   |word   |word   |word   |word   |word   |word   |word   |
|TUseRs         |1      |1      |1      |0      |1      |1      |1     |$\infty$|$\infty$|
|TUseRt         |1      |1      |$\infty$|0     |2      |2     |$\infty$|$\infty$|$\infty$|
|TNew           |3      |3      |3      |0      |0      |4      |3      |3      |0      |
|ALUOp[3:0]     |add    |sub    |or     |add    |add    |add    |lui    |default|default|
|CmpOp[3:0]     |beq    |beq    |beq    |beq    |beq    |beq    |beq    |beq    |beq    |
* Note: 
    1. "TNew" refers to the $T_{New}$ in Level F.
    2. passing ctrl signal by a 31 length vector.
    3. $\infty$ can be relized by value 3 in TUse.

## 顶层设计

设计文档有很多地方说不清楚，所以附了一张电路图
![top_design](CIRC.jpg)

## 思考题
> 1、我们使用提前分支判断的方法尽早产生结果来减少因不确定而带来的开销，但实际上这种方法并非总能提高效率，请从流水线

&ensp;&ensp;&ensp;&ensp;我们的预判很简单，就会猜测总是跳转。因此当总是不跳转的时候就是我们想要的反例。对于更加复杂的情况也类似，我们只需要朝猜错的方向去构造，并在每一次猜错前和猜错后的指令区域放上不阻塞的指令就可以了。
&ensp;&ensp;&ensp;&ensp;但是实际上考虑到延迟槽的存在，并考虑到我们的CPU只有五级流水线并且在第二级实现跳转判断。因此分支判断的影响并没有那么大。

> 2、因为延迟槽的存在，对于 jal 等需要将指令地址写入寄存器的指令，要写回 PC + 8，请思考为什么这样设计？

&ensp;&ensp;&ensp;&ensp;因为延迟槽指令不会产生任何影响，不必要执行。直接使用PC+8会更加合适。

> 3、我们要求大家所有转发数据都来源于流水寄存器而不能是功能部件（如 DM 、 ALU ），请思考为什么？

&ensp;&ensp;&ensp;&ensp;来自功能部件意味着转发的数据需要经过一段较长的路径才能转发，使得转发数据的关键路径变长，进而使得毛刺的出现成为可能，有可能会影响CPU运行

> 4、我们为什么要使用 GPR 内部转发？该如何实现？

&ensp;&ensp;&ensp;&ensp;其实不使用GRF内部转发也不是不行，W级向D级转发就行。为的是在W级尚未写入但D级需要读取的时候满足D级的读取需求。
&ensp;&ensp;&ensp;&ensp;实现起来其实很简单嘛。在GRF内部读出的数据做一个选择。如果写入的地址和读出的地址相同并且写入有效信号有效时，就读出写入的数据，同时将数据写入。即在GRF内部将写入数据转发到读出端口中

> 5、我们转发时数据的需求者和供给者可能来源于哪些位置？共有哪些转发数据通路？

&ensp;&ensp;&ensp;&ensp;总共有5个接收端点和2个转发端点。直接看电路图会更直观。

> 6、在课上测试时，我们需要你现场实现新的指令，对于这些新的指令，你可能需要在原有的数据通路上做哪些扩展或修改？提示：你可以对指令进行分类，思考每一类指令可能修改或扩展哪些位置。

指令类别：
* 计算类指令：算。
* 条件跳转链接指令：根据条件是否生效判断是否跳转且是否链接
* 条件跳转寄存器链接指令：根据条件是否生效判断是否跳转寄存器且是否链接
* 条件内存存储指令：根据条件是否生效存储不同的数据进入内存或者不存储
* 内存读取指令：读取内存

增改位置：
|位置|cal类|jxxal类|jxxalr类|sxx类|
| :-: | :-: | :-: | :-: | :-: |
|header     |**1**|**1**|**1**|**1**|
|CTRL     |**1**|**1**|**1**|**1**|
|各级Reg     |**1**|**1**|**1**|**1**|
|ALU        |**1**|0  |0  |0  |
|Cmp        |0  |**1**|**1**|0  |
|写入数据   |0  |0  |0  |**1**|

> 7、确定你的译码方式，简要描述你的译码器架构，并思考该架构的优势以及不足。

采用**集中式译码**
优势：少用控制器，节省资源；便于根据各级计算结果更改下一级的控制信号
不足：编写起来十分复杂。不好debug
